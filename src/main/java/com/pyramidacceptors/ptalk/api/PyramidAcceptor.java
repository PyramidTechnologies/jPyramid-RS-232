/*
 * Copyright (C) 2014 Pyramid Technologies, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package com.pyramidacceptors.ptalk.api;

import static com.pyramidacceptors.ptalk.api.event.Events.*;
import com.pyramidacceptors.ptalk.api.event.*;
import java.util.EnumSet;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * The Pyramid Acceptor class is the realization of an {@code ICommDevice}.<br>
 * It uses a RS-232 socket by default.<br>
 * <br>
 * @author Cory Todd <cory@pyramidacceptors.com>
 * @since 1.0.0.0
 */
public class PyramidAcceptor implements ICommDevice, PTalkEventListener {
    
    private Courier courier;
    private final PyramidPort port;    
    private final IConfiguration config;
    
    private final int POLL_RATE_MAX = 1000;       
    private int pollRate = 100;                 // Default poll rate is 100 ms
    
    
    // Use CopyOnWriteArrayList to avoid ConcurrentModificationExceptions if a
    // listener attempts to remove itself during event notification.
    private final CopyOnWriteArrayList<PTalkEventListener> listeners 
            = new CopyOnWriteArrayList<>();
    
    
    /**
     * Create a new PyramidAcceptor
     * 
     * @param port
     * @param config 
     */
    private PyramidAcceptor(PyramidPort port, IConfiguration config) { 
        this.port = port; 
        this.config = config;
    }
    
    /**
     * Instantiate a new Pyramid Acceptor with an existing port<br>
     * <br>
     * @param portName OS string name of the port this is connected to
     * @return New instance of PyramidAcceptor
     * @throws com.pyramidacceptors.ptalk.api.PyramidDeviceException
     */
    public static PyramidAcceptor valueOfRS232(String portName) throws PyramidDeviceException {
        return new PyramidAcceptor(new PyramidPort.PortBuilder(portName).build(),
        RS232Configuration.INSTANCE);
    }
    
    /**
     * Generate a new PyramidAcceptor with a custom port configuration. This
     * instance of PyramidPort will still use the standard RS-232 packet unless
     * otherwise specified.
     * 
     * @param config
     * @param portName
     * @param baudRate
     * @param databits
     * @param stopbits
     * @param parity
     * @return new instance of PyramidAcceptor
     * @throws com.pyramidacceptors.ptalk.api.PyramidDeviceException
     */
    public static PyramidAcceptor valueOfRS232(IConfiguration config, String portName, int baudRate, 
            int databits, int stopbits, int parity) throws PyramidDeviceException {
            return new PyramidAcceptor(new PyramidPort.PortBuilder(portName)
                    .baudRate(baudRate).dataBits(databits).stopBits(stopbits)
                    .parity(parity).build(), config);

    }
    
    /**
     * Attempt to autodetect the connected slave and use a default RS-232<br>
     * configuration.
     * @return a new instance of PyramidAcceptor
     * @throws PyramidDeviceException if there are issues with the serial port
     */
    public static PyramidAcceptor valueOfRS232() throws PyramidDeviceException {
        String portName = PortScanner.find();
        if(!portName.equals("")){
            return new PyramidAcceptor(new PyramidPort.PortBuilder(portName).build(),
                RS232Configuration.INSTANCE);
        } else {
            throw new PyramidDeviceException("Unable to autodetect device", 
                    "", "");
        }
    }

     /**
     * Subscribe to events generated by this instance<br>. To apply an<br>
     * event filter, please set the eventMask in the relevant IConfiguration<br>
     * implemenmation.
     * @see com.pyramidacceptors.ptalk.api.IConfiguration
     * @see com.pyramidacceptors.ptalk.api.RS232Configuration
     * <br>
     * @param l PTalkEventListener
     */
    public void addChangeListener(PTalkEventListener l) {
      this.listeners.add(l);
    }

    /**
     * Unsubscribe to events generated by this instance<br>. To apply an <br>
     * event filter, please set the eventMask in the relevant IConfiguration<br>
     * implemenmation.
     * @see com.pyramidacceptors.ptalk.api.IConfiguration
     * @see com.pyramidacceptors.ptalk.api.RS232Configuration
    * <br>
    * @param l PTalkEventListener
    */    
    public void removeChangeListener(PTalkEventListener l) {
      this.listeners.remove(l);
    }   
    
    private void fireChangeEvent(PTalkEvent e) {
        for(PTalkEventListener l : listeners) {
            l.changeEventReceived(e);
        }
    }
    
    @Override
    public void connect() {             
        try {
            
            // If port is already open or can be opened successfully,
            // create a new courier and start polling
            if(port.isOpen() || port.openPort()) {
                
                courier = new Courier(port, pollRate, new RS232Socket());
                courier.addChangeListener(this);
                courier.start();
                Logger.getLogger(PyramidAcceptor.class.getName()).log(Level.INFO, 
                        String.format("Connected to device on port %s",
                        port.getPortName()));
            
            } else {
                
                Logger.getLogger(PyramidAcceptor.class.getName()).log(Level.INFO, 
                        String.format("Failed to connect device on port %s", 
                        port.getPortName()));
            }
            
        }catch(PyramidDeviceException ex) {
            Logger.getLogger(PyramidAcceptor.class.getName()).log(Level.SEVERE,
                    null, ex);
        }
    }

    @Override
    public void disconnect() {      
       
        try {
            // Stop the message courier
            if(courier != null) {
                courier.stopThread();
                courier.removeChangeListener(this);
            }
            
            // And then see if we can close the port...
            if(port.closePort()) {
                Logger.getLogger(PyramidAcceptor.class.getName()).log(Level.INFO, 
                        String.format("Disconnect device from port %s", 
                        port.getPortName()));
            
            } else {
                Logger.getLogger(PyramidAcceptor.class.getName()).log(Level.INFO, 
                        String.format("Failed to disconnect device on port %s", 
                        port.getPortName()));
            }
            
        } catch(PyramidDeviceException ex) {
            Logger.getLogger(PyramidAcceptor.class.getName()).log(Level.SEVERE,
                    null, ex);
        }
    }

//    @Override
//    public void getStatus() {
//        throw new UnsupportedOperationException("Not supported yet.");
//    }

    @Override
    public int getPollRate() {
        return pollRate;
    }
    
    @Override
    public boolean setPollRate(int rate) {
        if(rate < 0 || rate > POLL_RATE_MAX)
            return false;
        
        pollRate = rate;
        return true;
    }

    @Override
    public boolean isConnected() {
        return port.isOpen();
    }

    @Override
    public String getPortName() {
        return port.getPortName();
    }

    @Override
    public void changeEventReceived(PTalkEvent evt) {
        
        // TODO implement event filter
        
        EnumSet<Events> event = evt.getEventId();
        int eventMask = RS232Configuration.INSTANCE.getEventMask();
        
        // States - only one state allowed at a time so save
        if(event.contains(Idling) && 
                ((Idling.getIntId()& eventMask) == Idling.getIntId())) {
            fireChangeEvent(new IdlingEvent(evt));
        }
        if(event.contains(Accepting) && 
                ((Accepting.getIntId()& eventMask) == Accepting.getIntId())) {
            fireChangeEvent(new AcceptingEvent(evt));
        }
        if(event.contains(Escrowed) && 
                ((Escrowed.getIntId()& eventMask) == Escrowed.getIntId())) {
            fireChangeEvent(new EscrowedEvent(evt));
        }
        if(event.contains(Stacking) && 
                ((Stacking.getIntId()& eventMask) == Stacking.getIntId())) {
            fireChangeEvent(new StackingEvent(evt));
        }        
        if(event.contains(Returning) && 
                ((Returning.getIntId()& eventMask) == Returning.getIntId())) {
            fireChangeEvent(new ReturningEvent(evt));
        }                
        if(event.contains(Stacked) && 
                ((Stacked.getIntId()& eventMask) == Stacked.getIntId())) {
            fireChangeEvent(new StackedEvent(evt));
        }
        if(event.contains(BillJammed) && 
                ((BillJammed.getIntId()& eventMask) == BillJammed.getIntId())) {
            fireChangeEvent(new BillJammedEvent(evt));
        }        
        if(event.contains(StackerFull) && 
                ((StackerFull.getIntId()& eventMask) == StackerFull.getIntId())) {
            fireChangeEvent(new StackerFullEvent(evt));
        } 
        
        // Events - there can be multiple so check them all
        if(event.contains(Returned) && 
                ((Returned.getIntId()& eventMask) == Returned.getIntId())) {
            fireChangeEvent(new EscrowedEvent(evt));
        }
        if(event.contains(Cheated) && 
                ((Cheated.getIntId()& eventMask) == Cheated.getIntId())) {
            fireChangeEvent(new CheatedEvent(evt));
        }
        if(event.contains(BillRejected) && 
                ((BillRejected.getIntId()& eventMask) == BillRejected.getIntId())) {
            fireChangeEvent(new BillRejectedEvent(evt));
        } 
        if(event.contains(BillCasetteRemoved) && 
                ((BillCasetteRemoved.getIntId()& eventMask) == BillCasetteRemoved.getIntId())) {
            fireChangeEvent(new CasseteMissingEvent(evt));
        }  
        if(event.contains(Failure) && 
                ((Failure.getIntId()& eventMask) == Failure.getIntId())) {
            fireChangeEvent(new FailureEvent(evt));
        }  
        if(event.contains(InvalidCommand) && 
                ((InvalidCommand.getIntId()& eventMask) == InvalidCommand.getIntId())) {
            fireChangeEvent(new InvalidMessageEvent(evt));
        }          
        if(event.contains(PowerUp) && 
                ((PowerUp.getIntId()& eventMask) == PowerUp.getIntId())) {
            fireChangeEvent(new PowerUpEvent(evt));
        }          
        if(event.contains(Credit) && 
                ((Credit.getIntId()& eventMask) == Credit.getIntId())) {
            fireChangeEvent(new CreditEvent(evt));
        }          

        // If we caught a generic event or something that we couldn't parse
        if(event.contains(Generic) || event.isEmpty() && 
                ((Generic.getIntId()& eventMask) == Generic.getIntId())) {
                fireChangeEvent(evt);                
        }
    }
}
